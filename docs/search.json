[{"path":"https://sachsmc.github.io/causaloptim/articles/example-code.html","id":"confounded-exposure-and-outcome","dir":"Articles","previous_headings":"","what":"confounded exposure and outcome","title":"Code from examples in manuscript","text":"","code":"b <- initialize_graph(graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) V(b)$nvals <- c(3,2,2)  obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") optimize_effect_2(obj) #> lower bound =   #> MAX { #>   -1 + p00_ + p11_ #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1 - p10_ - p01_ #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element.   obj2 <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 2) = 1} - p{Y(X = 0) = 1}\") optimize_effect_2(obj2) #> lower bound =   #> MAX { #>   -p10_ - p20_ - p01_ - p11_ #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1 - p20_ - p01_ #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element.   obj3 <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 2) = 1} - p{Y(X = 1) = 1}\") optimize_effect_2(obj3) #> lower bound =   #> MAX { #>   -p00_ - p20_ - p01_ - p11_ #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1 - p20_ - p11_ #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element."},{"path":"https://sachsmc.github.io/causaloptim/articles/example-code.html","id":"multiple-instruments","dir":"Articles","previous_headings":"","what":"multiple instruments","title":"Code from examples in manuscript","text":"run, takes minutes compute.","code":"b <- graph_from_literal(Z1 -+ X, Z2 -+ X, Z2 -+ Z1, Ul -+ Z1, Ul -+ Z2,                         X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(1, 0, 1, 1, 0, 0) V(b)$latent <- c(0, 0, 0, 1, 0, 1) V(b)$nvals <- c(2, 2, 2, 2, 2, 2) E(b)$rlconnect <- c(0, 0, 0, 0, 0, 0, 0, 0) E(b)$edge.monotone <- c(0, 0, 0, 0, 0, 0, 0, 0)  obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\")  bounds.multi <- optimize_effect_2(obj)  b2 <- graph_from_literal(Z1 -+ X, Ul -+ Z1,                          X -+ Y, Ur -+ X, Ur -+ Y) V(b2)$leftside <- c(1, 0, 1, 0, 0) V(b2)$latent <- c(0, 0, 1, 0, 1) V(b2)$nvals <- c(2, 2, 2, 2, 2) E(b2)$rlconnect <- c(0, 0,  0, 0, 0) E(b2)$edge.monotone <- c(0, 0, 0, 0, 0)   ## single instrument obj2 <- analyze_graph(b2, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") bounds.sing <- optimize_effect_2(obj2)   b3 <- graph_from_literal(Z3 -+ X, Ul -+ Z3,                          X -+ Y, Ur -+ X, Ur -+ Y) V(b3)$leftside <- c(1, 0, 1, 0, 0) V(b3)$latent <- c(0, 0, 1, 0, 1) V(b3)$nvals <- c(4, 2, 2, 2, 2) E(b3)$rlconnect <- c(0, 0,  0, 0, 0) E(b3)$edge.monotone <- c(0, 0, 0, 0, 0)   ## single instrument obj3 <- analyze_graph(b3, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") bounds.quad <- optimize_effect_2(obj3)   joint <- function(df, alpha, pUr, pUl) {    Z1 <- df$Z1   Z2 <- df$Z2   X <- df$X   Y <- df$Y    pUr * pUl * (((pnorm(alpha[1] + alpha[2] * 1)) ^ Z1 * (1 - pnorm(alpha[1] + alpha[2] * 1)) ^ (1 - Z1)) *                  ((pnorm(alpha[3] + alpha[4] * 1 + alpha[5] * Z1)) ^ Z2 *                     (1 - pnorm(alpha[3] + alpha[4] * 1 + alpha[5] * Z1)) ^ (1 - Z2)) *                  ((pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 1)) ^ X *                     (1 - pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 1)) ^ (1 - X)) *                  (pnorm(alpha[10] + alpha[11] * X + alpha[12] * 1)) ^ Y *                  (1 - pnorm(alpha[10] + alpha[11] * X + alpha[12] * 1)) ^ (1 - Y)) +     pUr * (1 - pUl) * (((pnorm(alpha[1] + alpha[2] * 0)) ^ Z1 * (1 - pnorm(alpha[1] + alpha[2] * 0)) ^ (1 - Z1)) *                          ((pnorm(alpha[3] + alpha[4] * 0 + alpha[5] * Z1)) ^ Z2 *                             (1 - pnorm(alpha[3] + alpha[4] * 0 + alpha[5] * Z1)) ^ (1 - Z2)) *                          ((pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 1)) ^ X *                             (1 - pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 1)) ^ (1 - X)) *                          (pnorm(alpha[10] + alpha[11] * X + alpha[12] * 1)) ^ Y *                          (1 - pnorm(alpha[10] + alpha[11] * X + alpha[12] * 1)) ^ (1 - Y)) +     (1 - pUr) * pUl * (((pnorm(alpha[1] + alpha[2] * 1)) ^ Z1 * (1 - pnorm(alpha[1] + alpha[2] * 1)) ^ (1 - Z1)) *                          ((pnorm(alpha[3] + alpha[4] * 1 + alpha[5] * Z1)) ^ Z2 *                             (1 - pnorm(alpha[3] + alpha[4] * 1 + alpha[5] * Z1)) ^ (1 - Z2)) *                          ((pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 0)) ^ X *                             (1 - pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 0)) ^ (1 - X)) *                          (pnorm(alpha[10] + alpha[11] * X + alpha[12] * 0)) ^ Y *                          (1 - pnorm(alpha[10] + alpha[11] * X + alpha[12] * 0)) ^ (1 - Y)) +     (1 - pUr) * (1 - pUl) * (((pnorm(alpha[1] + alpha[2] * 0)) ^ Z1 * (1 - pnorm(alpha[1] + alpha[2] * 0)) ^ (1 - Z1)) *                                ((pnorm(alpha[3] + alpha[4] * 0 + alpha[5] * Z1)) ^ Z2 *                                   (1 - pnorm(alpha[3] + alpha[4] * 0 + alpha[5] * Z1)) ^ (1 - Z2)) *                                ((pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 0)) ^ X *                                   (1 - pnorm(alpha[6] + alpha[7] * Z1 + alpha[8] * Z2 + alpha[9] * 0)) ^ (1 - X)) *                                (pnorm(alpha[10] + alpha[11] * X + alpha[12] * 0)) ^ Y *                                (1 - pnorm(alpha[10] + alpha[11] * X + alpha[12] * 0)) ^ (1 - Y))   }   ## get conditional probabilities ## key = XY_Z1Z2  get_cond_probs <- function(p.vals) {    z1z2.joint <- unique(p.vals[, c(\"Z1\", \"Z2\")])   for(j in 1:nrow(z1z2.joint)) {     z1z2.joint$Prob.condz1z2[j] <- sum(subset(p.vals, Z1 == z1z2.joint[j, \"Z1\"] & Z2 == z1z2.joint[j, \"Z2\"])$Prob)    }    p.vals.2 <- merge(p.vals, z1z2.joint, by = c(\"Z1\", \"Z2\"), sort = FALSE)    p.vals.2$Prob.cond.fin <- ifelse(p.vals.2$Prob ==0, 0.0, p.vals.2$Prob / p.vals.2$Prob.condz1z2)   res <- as.list(p.vals.2$Prob.cond.fin)   names(res) <- with(p.vals.2, paste0(\"p\", X, Y, \"_\", Z1, Z2))    ## conditional on Z1 only    xyz1.joint <- unique(p.vals[, c(\"Z1\", \"X\", \"Y\")])   for(j in 1:nrow(xyz1.joint)) {      xyz1.joint$Prob.xyz1[j] <- sum(subset(p.vals, Z1 == xyz1.joint$Z1[j] &                                             X == xyz1.joint$X[j] & Y == xyz1.joint$Y[j])$Prob)    }    z1.marg0 <- sum(subset(xyz1.joint, Z1 == 0)$Prob.xyz1)   z1.marg1 <-   sum(subset(xyz1.joint, Z1 == 1)$Prob.xyz1)    xyz1.joint$Prob.z1[xyz1.joint$Z1 == 0] <- z1.marg0   xyz1.joint$Prob.z1[xyz1.joint$Z1 == 1] <- z1.marg1    xyz1.joint$Prob.cond <- with(xyz1.joint, Prob.xyz1 / Prob.z1)   res2 <- as.list(xyz1.joint$Prob.cond)   names(res2) <- with(xyz1.joint, paste0(\"p\", X, Y, \"_\", Z1))         ## conditioning on Z3      z3.joint <- unique(p.vals[, c(\"Z3\"), drop = FALSE])   for(j in 1:nrow(z3.joint)) {     z3.joint$Prob.condz3[j] <- sum(subset(p.vals, Z3 == z3.joint[j, \"Z3\"])$Prob)   }    p.vals.3 <- merge(p.vals, z3.joint, by = c(\"Z3\"), sort = FALSE)    p.vals.3$Prob.cond.fin <- ifelse(p.vals.3$Prob ==0, 0.0, p.vals.3$Prob / p.vals.3$Prob.condz3)   res3 <- as.list(p.vals.3$Prob.cond.fin)   names(res3) <- with(p.vals.3, paste0(\"p\", X, Y, \"_\", Z3))     list(multi = res,         sing = res2,        quad = res3)  }    ## simulate and compare the two nsim <- 50000 f.multi <- interpret_bounds(bounds.multi$bounds, obj$parameters) f.single <- interpret_bounds(bounds.sing$bounds, obj2$parameters) f.quad <- interpret_bounds(bounds.quad$bounds, obj3$parameters)  result <- matrix(NA, ncol = 9, nrow = nsim)  set.seed(211129) for (i in 1:nsim) {    alpha <- rnorm(12, sd = 2)   pUr <- runif(1)   pUl <- runif(1)    p.vals.joint <- obj$p.vals   p.vals.joint$Prob <- joint(p.vals.joint, alpha, pUr, pUl)      p.vals.joint$Z3 <- with(p.vals.joint, ifelse(Z1 == 0 & Z2 == 0, 0,                                                 ifelse(Z1 == 0 & Z2 == 1, 1,                                                        ifelse(Z1 == 1 & Z2 == 0, 2,                                                               3))))      if(any(p.vals.joint$Prob == 0)) next    condprobs <- get_cond_probs(p.vals.joint)    bees <- do.call(f.multi, condprobs$multi)   bees.sing <- do.call(f.single, condprobs$sing)   bees.quad <- do.call(f.quad, condprobs$quad)      result[i, ] <- unlist(c(sort(unlist(bees)), abs(bees[2] - bees[1]),                            sort(unlist(bees.sing)), abs(bees.sing[2]- bees.sing[1]),                           sort(unlist(bees.quad)), abs(bees.quad[2]- bees.quad[1])))  } colnames(result) <- c(\"bound.lower\",                       \"bound.upper\", \"width.multi\",                       \"bound.lower.single\", \"bound.upper.single\", \"width.single\",                        \"bound.lower.quad\", \"bound.upper.quad\", \"width.quad\") bounds.comparison <- as.data.frame(result)  #pdf(\"figsim.pdf\", width = 8, height = 4.25, family = \"serif\") par(mfrow = c(1,2)) plot(width.multi ~ width.single, data = bounds.comparison, pch = 20, cex = .3,      xlim = c(0, 1), ylim = c(0, 1), xlab= \"Single IV\", ylab = \"Two binary IV/Single 4-level IV\",      main = \"Width of bounds intervals\") abline(0, 1, lty = 3)  plot(bound.lower.quad ~ bound.lower, data = bounds.comparison[1:100,], pch = 20, cex = 1,       xlim = c(-1, 1), ylim = c(-1, 1), xlab = \"Two binary IV\", ylab = \"Single 4-level IV\",       main = \"Bounds values\") points(bound.upper.quad ~ bound.upper, data = bounds.comparison[1:100,], pch = 1, cex = 1)  legend(\"bottomright\", pch = c(1, 20), legend = c(\"upper\", \"lower\")) #dev.off()  summary(bounds.comparison) # contains 467 NA's to avoid division by 0 # Verify that a single quad-level instrument yield the same bounds as two linked binary ones. all(round(x = bounds.comparison$bound.lower, digits = 12) ==          round(x = bounds.comparison$bound.lower.quad, digits = 12) &&          round(x = bounds.comparison$bound.upper, digits = 12) ==          round(x = bounds.comparison$bound.upper.quad, digits = 12),      na.rm = TRUE)"},{"path":"https://sachsmc.github.io/causaloptim/articles/example-code.html","id":"measurement-error-in-the-outcome","dir":"Articles","previous_headings":"","what":"measurement error in the outcome","title":"Code from examples in manuscript","text":"","code":"b <- graph_from_literal(Ul -+ X -+ Y -+ Y2, Ur -+ Y, Ur -+ Y2) V(b)$leftside <- c(1, 1, 0, 0, 0) V(b)$latent <- c(1, 0, 1, 0, 1) V(b)$nvals <- c(2, 2, 2, 2, 2) E(b)$rlconnect <- c(0, 0, 0, 0, 0) E(b)$edge.monotone <- c(0, 0, 0, 0, 0)  obj <- analyze_graph(b, constraints = \"Y2(Y = 1) >= Y2(Y = 0)\",                      effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\")  optimize_effect_2(obj) #> lower bound =   #> MAX { #>   -1, #>   -1 + 2p0_0 - 2p0_1 #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1, #>   1 + 2p0_0 - 2p0_1 #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element."},{"path":"https://sachsmc.github.io/causaloptim/articles/shinyapp.html","id":"specifying-the-causal-effect-of-interest","dir":"Articles","previous_headings":"","what":"Specifying the causal effect of interest","title":"How to use the causaloptim Shiny app to analyze graphs","text":"next step use text box specify causal effect interest. current example, interested causal risk difference Y comparing X = 1 X = 0, .e., Y(X = 1) - Y(X = 0). optimizer compute bounds expected value quantity. Use text box describe causal effect interest. effects must form Vij names variables graph, , b corresponding values, op either - +. can specify single probability statement (.e., operator). Note probability statements begin little p, use curly braces, items inside probability statements separated ;. variables may potential outcomes denoted parentheses. Variables may also nested inside potential outcomes. Pure observations p{Y = 1} allowed left side contains variables. left side contains variables, mush ancestors intervention set variables (intervention variables ). following valid effect statements: Back example, specify effect click “parse” button fix effect.","code":"p{V11(X=a)=a; V12(X=a)=b;...} op1 p{V21(X=b)=a; V22(X=c)=b;...} op2 ... p{Y(X = 1) = 1} - p{Y(X = 0) = 1} p{X(Z = 1) = 1; X(Z = 0) = 0} p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1} p{Y(X = 1) = 1} - p{Y(X = 0) = 1}"},{"path":"https://sachsmc.github.io/causaloptim/articles/shinyapp.html","id":"specifying-constraints-optional","dir":"Articles","previous_headings":"","what":"Specifying constraints (optional)","title":"How to use the causaloptim Shiny app to analyze graphs","text":"causal effect interest specified, may optionally specify constraints. Click button start constraint interface. can specify potential outcomes constrain writing potential outcomes, values parents, operators determine constraint (equalities inequalities). example, can specify monotonicity instrument Z defining constraint X(Z = 1) ≥\\geq X(Z = 0): click parse.","code":"X(Z = 1) >= X(Z = 0)"},{"path":"https://sachsmc.github.io/causaloptim/articles/shinyapp.html","id":"computation-of-the-bounds","dir":"Articles","previous_headings":"","what":"Computation of the bounds","title":"How to use the causaloptim Shiny app to analyze graphs","text":"inspected graph, specified causal effect, understand analyzed, press final button compute bounds. Note computation may take significant amount time. results summarized plain text. bounds expressed minimum/maximum series expressions involving conditional probabilities observed variables. details method see paper. final button allows return objects back R environment store results. results object contains graph, parameterization interpretation graph terms variables parameters, bounds log information optimization procedure, R function implements bounds: results object can also used numerically simulate bounds. Try using simulate_bounds function. also provide helper function print bounds latex equations. Use latex_bounds function. Lower bound=P(X=0,Y=0|Z=0)−P(X=0,Y=0|Z=1)−P(X=1,Y=0|Z=1)−P(X=0,Y=1|Z=1)   \\mbox{Lower bound} =   P(X = 0, Y = 0 | Z = 0) - P(X = 0, Y = 0 | Z = 1) - P(X = 1, Y = 0 | Z = 1) - P(X = 0, Y = 1 | Z = 1)   Upper bound=1−P(X=1,Y=0|Z=1)−P(X=0,Y=1|Z=0)   \\mbox{Upper bound} =   1 - P(X = 1, Y = 0 | Z = 1) - P(X = 0, Y = 1 | Z = 0) Please sends bugs feedback sachsmc@gmail.com file issue https://github.com/sachsmc/causaloptim .","code":"names(results) #> [1] \"graphres\"       \"obj\"            \"bounds.obs\"     \"constraints\"    #> [5] \"effect\"         \"boundsFunction\"  print(results$bounds.obs) #> lower bound =   #> MAX { #>   p00_0 - p00_1 - p10_1 - p01_1 #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1 - p10_1 - p01_0 #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element.  print(results$boundsFunction) #> function (p00_0 = NULL, p00_1 = NULL, p10_0 = NULL, p10_1 = NULL,  #>     p01_0 = NULL, p01_1 = NULL, p11_0 = NULL, p11_1 = NULL)  #> { #>     lb <- pmax(p00_0 - p00_1 - p10_1 - p01_1) #>     ub <- pmin(1 - p10_1 - p01_0) #>     if (any(ub < lb)) { #>         warning(\"Invalid bounds! Data probably does not satisfy the assumptions in the DAG!\") #>     } #>     data.frame(lower = lb, upper = ub) #> } sim <- simulate_bounds(results$obj, results$bounds.obs, nsim = 100) head(sim) #>     objective bound.lower bound.upper #> 1  0.11072239  -0.2765626   0.4145571 #> 2  0.04677063  -0.3380446   0.4131181 #> 3 -0.20689850  -0.4887614   0.1605880 #> 4  0.14317449  -0.2369513   0.3885858 #> 5  0.02464152  -0.3451034   0.3450640 #> 6  0.09175714  -0.2020024   0.3795258 cat(latex_bounds(results$bounds.obs$bounds, results$obj$parameters))"},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"what-is-causaloptim","dir":"Articles","previous_headings":"","what":"What is causaloptim?","title":"Improving the speed of computing causal bounds","text":"summary, causaloptim computes symbolic tight bounds causal effects. Suppose causal graph GG want estimate effect ACE(X→Y)\\text{ACE}(X\\rightarrow Y). unmeasured confounding effect, determined. However, can still try find good bounds ! Let’s pretend confounding fact measured, estimate distribution qq. , given qq, effect ACEq(X→Y)\\text{ACE}_{q}(X\\rightarrow Y) identifiable. Now, even though don’t actually know qq, surely know something ; needs consistent structure GG, satisfies constraint, say q∈𝒜q\\\\mathcal{}. assumptions, ACEq(X→Y)\\text{ACE}_{q}(X\\rightarrow Y) valid w.r.t. GG q∈𝒜q\\\\mathcal{}, finding tight bounds ACE(X→Y)\\text{ACE}(X\\rightarrow Y) becomes constrained optimization problem; simply find extrema {ACEq(X→Y):q∈𝒜}\\{\\text{ACE}_{q}(X\\rightarrow Y):q\\\\mathcal{}\\}. given estimate distribution pp measured variables, try large number simulations numerically approximate bounds, can actually solve problem analytically get closed form expressions bounds terms pp? certain class problems, turns can! precisely causaloptim , post highlight inner workings recent efficiency improvements. tutorial get started using causaloptim, look post.","code":""},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"background","dir":"Articles","previous_headings":"","what":"Background","title":"Improving the speed of computing causal bounds","text":"Back 1995, [Balke & Pearl]1 showed classic example experiment potential non-compliance. shortly, summary showed translate causal problem linear programming one leverage tools linear optimization compute bounds. Balke even wrote command line program C++ computes , given linear program (LP) input. program used successfully researchers causal inference since , issues preventing wider adoption among applied researchers. causaloptim written solve problems. can handle generalized class problems defined [Sachs & Jonzon & Gabriel & Sjölander]2. removes burden translating causal problem LP intuitive graphical user interface guides user specifying DAG causal query. version 0.7.1 used Balke’s code optimization. However, non-trivial instances generalized class causaloptim handles, original optimization algorithm task.","code":""},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"efficiency-matters","dir":"Articles","previous_headings":"","what":"Efficiency matters!","title":"Improving the speed of computing causal bounds","text":"Let’s time following simple enough looking multiple instrument problem. Benchmark Example. Multiple Instruments. Using causaloptim version 0.7.1 bound ACE(X→Y)\\text{ACE}(X\\rightarrow Y) got (3.3 GHz Quad-Core Intel Core i5; mileage may vary) Note times (seconds)! 😱 CPU spent almost 99 hours working ! 🤖 spent 1717 hours waiting! 😴 Correctness enough; wait next day bad user experience. Using causaloptim version 0.8.0 however, get Now acceptable! 😊 course, need verify results . difficult see upon visual inspection , vertices returned different order (lots ). Instead can randomly generate probability distributions satisfy graph, compute bounds compare results. First, create R functions compute bounds: , create distribution first randomly generating counterfactual probabilities, calculating observable probabilities using constraints implied DAG (live constraints element obj). pass probabilities bounds functions compare: Success! improvement achieved modernizing key back-end optimization algorithm implementation. see fits bigger picture, let’s first see causaloptim sets optimization problem.","code":"library(causaloptim) library(igraph) b <- graph_from_literal(Z1 -+ X, Z2 -+ X, Z2 -+ Z1, Ul -+ Z1, Ul -+ Z2, X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(1, 0, 1, 1, 0, 0) V(b)$latent <- c(0, 0, 0, 1, 0, 1) V(b)$nvals <- c(2, 2, 2, 2, 2, 2) E(b)$rlconnect <- c(0, 0, 0, 0, 0, 0, 0, 0) E(b)$edge.monotone <- c(0, 0, 0, 0, 0, 0, 0, 0) obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") system.time(oldbnds <- optimize_effect(obj)) #>     user  system  elapsed  #> 31093.57   47.02 61368.22 system.time(newbnds <- optimize_effect_2(obj)) #>  user  system  elapsed  #> 0.139   0.001    0.140 eval_newbnds <- interpret_bounds(newbnds$bounds, obj$parameters) eval_oldbnds <- interpret_bounds(oldbnds$bounds, obj$parameters) sim.qs <- rbeta(length(obj$variables), .05, 1) sim.qs <- sim.qs / sum(sim.qs)  names(sim.qs) <- obj$variables  inenv <- new.env() for(j in 1:length(sim.qs)) {          assign(names(sim.qs)[j], sim.qs[j], inenv)      } res <- lapply(as.list(obj$constraints[-1]), function(x){     x1 <- strsplit(x, \" = \")[[1]]     x0 <- paste(x1[1], \" = \", x1[2])     eval(parse(text = x0), envir = inenv) })  params <- lapply(obj$parameters, function(x) get(x, envir = inenv)) names(params) <- obj$parameters do.call(eval_newbnds, params)  #>           lower       upper #> q0_0 -0.3148649 -0.08804175 do.call(eval_oldbnds, params) #>           lower       upper #> q0_0 -0.3148649 -0.08804175"},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"how-does-causaloptim-work","dir":"Articles","previous_headings":"","what":"How does causaloptim work?","title":"Improving the speed of computing causal bounds","text":"Given DAG DD, causally relating set 𝒱\\mathcal{V} measured binary variables, suppose can bipart 𝒱\\mathcal{V} association two parts causal directed one part (call ℒ\\mathcal{L}) (called ℛ\\mathcal{R}), want determine effect ACE(X→Y)\\text{ACE}(X\\rightarrow Y) variable XX variable Y∈ℛY\\\\mathcal{R}. guiding example, let’s follow along original one given Balke & Pearl. Original Example: User Input DAG DD. Since assume nothing apart macro-structure ℒ→ℛ∋Y\\mathcal{L}\\rightarrow\\mathcal{R}\\ni Y, must augment DD “worst case” scenario confounding among variable within parts ℒ\\mathcal{L} ℛ\\mathcal{R} get causal graph GG. specific causal graph can interpreted experiment potential non-compliance. three binary measured variables; treatment assigned ZZ, treatment taken XX outcome YY. want estimate ACE(X→Y)\\text{ACE}(X\\rightarrow Y), confounded unmeasured UU single instrument ZZ. Original Example: Causal Graph GG.","code":""},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"response-function-variables","dir":"Articles","previous_headings":"How does causaloptim work?","what":"Response Function Variables","title":"Improving the speed of computing causal bounds","text":"yields functional causal model {FV:pa(V)×UV→V∣V∈𝒱}\\{F_V:pa(V)\\times U_V\\V\\mid V\\\\mathcal{V}\\}, although computationally convenient form. However, assumption finite-valued measured variables V∈𝒱V\\\\mathcal{V}, can fact partition ranges unmeasured ones UV∈𝒰U_V\\\\mathcal{U} finitely many sets; simply enumerate finitely many distinct functions pa(V)→Vpa(V)\\V V∈𝒱V\\\\mathcal{V}. call canonical partition RVR_V UVU_V response function variable VV. Original Example: Response Function Variables. (dashed line signifies $R_X\\\\!\\perp\\!\\!\\!\\perp R_Y$.) context specific example, e.g. XX single parent RXR_X takes exactly 44 distinct values, say {0,1,2,3}\\{0,1,2,3\\} ∀z∈{0,1}\\forall z\\\\{0,1\\}, 𝐑𝐞𝐬𝐩𝐨𝐧𝐬𝐞 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐅𝐮𝐧𝐜𝐭𝐢𝐨𝐧𝐈𝐧𝐭𝐞𝐫𝐩𝐫𝐞𝐭𝐚𝐭𝐢𝐨𝐧r=0fX(z,0)=0never takes X, regardless Zr=1fX(z,1)=zfull compliance assignment Zr=2fX(z,2)=1−ztotal defiance assignment Zr=3fX(z,3)=1always takes X, regardless Z\\begin{matrix} \\textbf{Response Pattern}&\\textbf{Function}&\\textbf{Interpretation}\\\\ r=0&f_X(z,0)=0&\\text{never takes $X$, regardless $Z$}\\\\ r=1&f_X(z,1)=z&\\text{full compliance assignment $Z$}\\\\ r=2&f_X(z,2)=1-z&\\text{total defiance assignment $Z$}\\\\ r=3&f_X(z,3)=1&\\text{always takes $X$, regardless $Z$}\\\\ \\end{matrix}","code":""},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"parameters-and-their-relationships","dir":"Articles","previous_headings":"How does causaloptim work?","what":"Parameters and their Relationships","title":"Improving the speed of computing causal bounds","text":"can observe outcomes variables 𝒱\\mathcal{V}, can estimate joint distribution, fact need conditional distribution given ℒ\\mathcal{L}, let’s establish notation . specific example define p(y,x;z):=P(y,x|z),∀x,y,x∈{0,1}p_{(y,x;z)}:=P(y,x|z),\\quad\\forall x,y,x\\\\{0,1\\} Although unknown, need notation distribution response function variables well. specific example requires q(rX,rY):=P(rX,rY),∀rX,rY∈{0,1,2,3}q_{(r_X,r_Y)}:=P(r_X,r_Y),\\quad\\forall r_X,r_Y\\\\{0,1,2,3\\} Markovian property, example yields p(y,x;z)=∑rX,rYP(y|x,rY)P(x|z,rX)q(rX,rY)p_{(y,x;z)}=\\sum_{r_X,r_Y}P(y|x,r_Y)P(x|z,r_X)q_{(r_X,r_Y)} Note coefficients deterministic binary, since e.g. P(y|x,rY)={1, y=fY(x,rY)0, otherwiseP(y|x,r_Y)=\\begin{cases}1&\\text{, }y=f_Y(x,r_Y)\\\\0&\\text{, otherwise}\\end{cases}, recursion applies complex examples. Thus, particular example, p=Rq matrix R∈{0,1}8×16p=Rq\\text{ matrix }R\\\\{0,1\\}^{8\\times16} , can express potential outcomes YY intervention XX terms parameters qq adjustment formula; P(y|(x))=∑rX,rYP(y|x,rY)q(rX,rY)P(y|(x))=\\sum_{r_X,r_Y}P(y|x,r_Y)q_{(r_X,r_Y)} Hence, ACEq(X→Y)=P(Y=1|(X=1))−P(Y=1|(X=0))=cTq vector c∈{0,1,−1}16\\begin{align*} \\text{ACE}_q(X\\rightarrow Y) &=P(Y=1|(X=1))-P(Y=1|(X=0))\\\\ &=c^Tq\\text{ vector }c\\\\{0,1,-1\\}^{16} \\end{align*}","code":""},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"linear-programming","dir":"Articles","previous_headings":"How does causaloptim work?","what":"Linear Programming","title":"Improving the speed of computing causal bounds","text":"Now constraints qq well effect interest terms qq ready optimize! adding probabilistic constraints qq arrived e.g. following LP giving tight lower bound ACE(X→Y)\\text{ACE}(X\\rightarrow Y): mincTqstΣq=1&Rq=p&q≥0\\begin{matrix} \\min&c^Tq\\\\ st&\\Sigma q=1\\\\ \\&&Rq=p\\\\ \\&&q\\geq0 \\end{matrix} Strong Duality Theorem3 convex optimization, optimal value primal problem equals dual. Furthermore, constraint space convex polytope Fundamental Theorem Linear Programming4, optimum attained one vertices. Consequently, minqACEq(X→Y)=min{cTq∣q∈ℝ16,q≥016×1,11×16q=1,Rq=p}=max{(1pT)y∣y∈ℝ9,y≥09×1,(116×1RT)≤c}=max{(1pT)y‾∣y‾ vertex {y∈ℝ9∣y≥09×1,(116×1RT)≤c}}\\begin{align*} \\min_q ACE_q(X\\rightarrow Y) &=\\min\\{c^Tq\\mid q\\\\mathbb{R}^{16},q\\geq0_{16\\times1},1_{1\\times16} q=1,Rq=p\\}\\\\ &=\\max\\{\\begin{pmatrix}1&p^T\\end{pmatrix}y\\mid y\\\\mathbb{R}^{9},y\\geq0_{9\\times1},\\begin{pmatrix}1_{16\\times1}&R^T\\end{pmatrix}\\leq c\\}\\\\ &=\\max\\{\\begin{pmatrix}1&p^T\\end{pmatrix}\\bar{y}\\mid\\bar{y}\\text{ vertex }\\{y\\\\mathbb{R}^{9}\\mid y\\geq0_{9\\times1},\\begin{pmatrix}1_{16\\times1}&R^T\\end{pmatrix}\\leq c\\}\\} \\end{align*} Since allow user provide additional linear inequality constraints (e.g. may quite reasonable assume proportion “defiers” study population example quite low), actual primal dual LP’s look slightly complicated, small example still captures essentials. general, Ae:=(1n×1TR)A_e:=\\begin{pmatrix}1_{n\\times1}^T\\\\R\\end{pmatrix}, :=(1p)b_e:=\\begin{pmatrix}1\\\\p\\end{pmatrix} user provided matrix inequality Aℓq≤bℓA_{\\ell}q\\leq b_{\\ell}, minq(ACE(→Y))=min({cTq∣q∈ℝn,Aℓq≤bℓ,Aeq=,q≥0n×1})=max({(bℓTbeT)y∣y∈ℝmℓ+,(AℓTAeT)y≤c,(Iml×ml0ml×)y≤0ml×1}=max({(bℓTbeT)y‾∣y‾ vertex {y∈ℝmℓ+∣(AℓTAeTIml×ml0ml×)y≤(c0ml×1)}})\\begin{align*}\\min_q(ACE(\\Y))&=\\min(\\{c^Tq\\mid q\\\\mathbb{R}^n,A_{\\ell}q\\leq b_{\\ell},A_eq=b_e,q\\geq0_{n\\times1}\\})\\\\ &=\\max(\\{\\begin{pmatrix}b_{\\ell}^T&b_e^T\\end{pmatrix}y\\mid y\\\\mathbb{R}^{m_{\\ell}+m_e},\\begin{pmatrix}A_{\\ell}^T&A_e^T\\end{pmatrix}y\\leq c,\\begin{pmatrix}I_{m_l\\times m_l}&0_{m_l\\times m_e}\\end{pmatrix}y\\leq0_{m_l\\times1}\\}\\\\ &=\\max(\\{\\begin{pmatrix}b_{\\ell}^T&b_e^T\\end{pmatrix}\\bar{y}\\mid\\bar{y}\\text{ vertex }\\{y\\\\mathbb{R}^{m_{\\ell}+m_e}\\mid\\begin{pmatrix}A_{\\ell}^T&A_e^T\\\\I_{m_l\\times m_l}&0_{m_l\\times m_e}\\end{pmatrix}y\\leq\\begin{pmatrix}c\\\\0_{m_l\\times1}\\end{pmatrix}\\}\\})\\end{align*} coefficient matrix right hand side vector dual polytope constructed lines code (c0:=cc_0:=c).","code":"a1 <- rbind(cbind(t(A_l), t(A_e)),             cbind(diag(x = 1, nrow = m_l, ncol = m_l), matrix(data = 0, nrow = m_l, ncol = m_e))) b1 <- rbind(c0,             matrix(data = 0, nrow = m_l, ncol = 1)) if (opt == \"max\") {   a1 <- -a1   b1 <- -b1 }"},{"path":"https://sachsmc.github.io/causaloptim/articles/vertexenum-speed.html","id":"vertex-enumeration","dir":"Articles","previous_headings":"How does causaloptim work?","what":"Vertex Enumeration","title":"Improving the speed of computing causal bounds","text":"last step vertex enumeration previously major computational bottleneck causaloptim. now replaced cddlib5, implementation Double Description Method (dd). convex polytope can dually described either intersection half-planes (form get dual constraint space ) minimal set vertices convex hull (form want ) dd algorithm efficiently converts two descriptions. cddlib also uses exact rational arithmetic, don’t worry numerical instability issues, e.g. Also, already interfaces R6. following lines code extract vertices dual polytope store rows matrix. rest simply matter plugging dual objective function, evaluating expression presenting results! first part done following line code, utility function evaluate_objective pretty much expect ((c1_num,p)=((bℓT1),p)=(\\begin{pmatrix}b_{\\ell}^T&1\\end{pmatrix},p) separates dual objective gradient numeric symbolic parts). still places causaloptim worthwhile optimize, major one resolved looking forward researchers taking advantage generalized class problems can handle! Happy bounding!","code":"library(rcdd) hrep <- makeH(a1 = a1, b1 = b1) vrep <- scdd(input = hrep) matrix_of_vrep <- vrep$output indices_of_vertices <- matrix_of_vrep[ , 1] == 0 & matrix_of_vrep[ , 2] == 1 vertices <- matrix_of_vrep[indices_of_vertices, -c(1, 2), drop = FALSE] expressions <- apply(vertices, 1, function(y) evaluate_objective(c1_num = c1_num, p = p, y = y))"},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Michael C Sachs. Author, maintainer. Erin E Gabriel. Author. Arvid Sjölander. Author. Gustav Jonzon. Author. Alexander Balke. Contributor.           (C++ code) Colorado Reed. Contributor.           (graph-creator.js)","code":""},{"path":"https://sachsmc.github.io/causaloptim/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sachs M, Gabriel E, Sjölander , Jonzon G (2025). causaloptim: Interface Specify Causal Graphs Compute Bounds Causal Effects. R package version 1.0.1, https://sachsmc.github.io/causaloptim/. Sachs M, Jonzon G, Gabriel E, Sjölander (2022). “general method deriving tight symbolic bounds causal effects.” Journal Computational Graphical Statistics, 1–10. doi:10.1080/10618600.2022.2071905.","code":"@Manual{,   title = {causaloptim: An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects},   author = {Michael C Sachs and Erin E Gabriel and Arvid Sjölander and Gustav Jonzon},   year = {2025},   note = {R package version 1.0.1},   url = {https://sachsmc.github.io/causaloptim/}, } @Article{,   title = {A general method for deriving tight symbolic bounds on causal effects},   author = {Michael C Sachs and Gustav Jonzon and Erin E Gabriel and Arvid Sjölander},   year = {2022},   journal = {Journal of Computational and Graphical Statistics},   pages = {1--10},   year = {2022},   publisher = {Taylor \\& Francis},   doi = {10.1080/10618600.2022.2071905}, }"},{"path":"https://sachsmc.github.io/causaloptim/index.html","id":"causaloptim-an-interface-to-specify-causal-graphs-and-compute-bounds-on-causal-effects","dir":"","previous_headings":"","what":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","text":"causal quantities identifiable observed data, still may possible bound quantities using observed data. outline class problems derivation tight bounds always linear programming problem can therefore, least theoretically, solved using symbolic linear optimizer. provide user friendly graphical interface setting problems via DAGs, allow problems within class depicted. user can define linear constraints refine assumptions meet specific problem, specify causal query using text interface. program converts user defined DAG, query, constraints, returns tight bounds. bounds can converted R functions evaluate specific datasets, latex code publication.","code":""},{"path":"https://sachsmc.github.io/causaloptim/index.html","id":"development-status","dir":"","previous_headings":"","what":"Development status","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","text":"package stable development. interface unlikely major changes time. New features may added time.","code":""},{"path":"https://sachsmc.github.io/causaloptim/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","text":"use web application: https://sachsmc.shinyapps.io/causaloptimweb/","code":"install.packages(\"causaloptim\") # or remotes::install_github(\"sachsmc/causaloptim\")"},{"path":"https://sachsmc.github.io/causaloptim/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","text":"Launch shiny app get started, results saved results object:","code":"results <- specify_graph()"},{"path":"https://sachsmc.github.io/causaloptim/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects","text":"Sachs, M. C., Jonzon, G., Sjölander, ., & Gabriel, E. E. (2023). general method deriving tight symbolic bounds causal effects. Journal Computational Graphical Statistics, 32(2), 567-576. https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2071905/ Jonzon, G., Sachs, M. C., & Gabriel, E. E. (2023). Accessible Computation Tight Symbolic Bounds Causal Effects using Intuitive Graphical Interface. R Journal, 15(4). https://journal.r-project.org/articles/RJ-2023-083/ . Balke J. Pearl, “Counterfactual Probabilities: Computational Methods,Bounds, Applications” UCLA Cognitive Systems Laboratory, Technical Report (R-213-B). R. Lopez de Mantaras D. Poole (Eds.), Proceedings Conference Uncertainty Artificial Intelligence (UAI-94), Morgan Kaufmann, San Mateo, CA, 46-54, July 29-31, 1994. https://ftp.cs.ucla.edu/pub/stat_ser/R213-B.pdf .","code":""},{"path":"https://sachsmc.github.io/causaloptim/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Michael C Sachs Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"graph must contain certain edge vertex attributes documented Details . shiny app run specify_graph return graph format.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"","code":"analyze_graph(graph, constraints, effectt)"},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"graph igraph-package object represents directed acyclic graph certain attributes. See Details. constraints vector character strings represent constraints counterfactual quantities effectt character string represents causal effect interest","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"object class \"linearcausalproblem\", list   following components. list can passed optimize_effect_2   interfaces symbolic optimization program. Print plot methods also   available. variables Character vector variable names   potential outcomes, start 'q' match Balke's notation parameters Character vector parameter names observed   probabilities, start 'p' match Balke's notation constraints Character vector parsed constraints objective Character string defining objective optimized   terms variables p.vals Matrix possible values   observed data vector, corresponding list parameters. q.vals Matrix possible values response function form   potential outcomes, corresponding list variables. parsed.query nested list containing information parsed   causal query. objective.nonreduced objective terms   original variables, algebraic variable reduction. nonreduced   variables can obtained concatenating columns q.vals. response.functions List response functions. graph graph passed function. R matrix coefficients   relating p.vals q.vals p = R * q c0 vector coefficients relating q.vals   objective function theta = c0 * q iqR matrix coefficients represent inequality   constraints","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"graph object must contain following named vertex attributes: name name vertex must valid R object name starting letter special characters. Good candidate names example, Z1, Z2, W2, X3, etc. leftside indicator whether vertex left side graph, 1 yes, 0 . latent indicator whether variable latent (unobserved). always variable Ul left side latent parent variables left side, another latent variable Ur right side parent variables right side. nvals number possible values variable can take , default minimum 2 2 categories (0,1). general, variable nvals K can take values 0, 1, ..., (K-1). addition, must following edge attributes: rlconnect indicator whether edge goes right side left side. 0 edges. edge.monotone indicator whether effect edge monotone, meaning V1 -> V2 edge monotone, > b implies V2(V1 = ) >= V2(V1 = b). available binary variables (nvals = 2). effectt parameter describes causal effect interest. effectt parameter must form p{V11(X=)=; V12(X=)=b;...} op1 p{V21(X=b)=; V22(X=c)=b;...} op2 ... Vij names variables graph, , b numeric values 0:(nvals - 1), op either - +. can specify single probability statement (.e., operator). Note probability statements begin little p, use curly braces, items inside probability statements separated ;. variables may potential outcomes denoted parentheses. Variables may also nested inside potential outcomes. Pure observations p{Y = 1} allowed left side contains variables. 2 important rules follow: 1) variables right side can probability events, left side empty: 2) none variables left side intervened upon can children left side, paths left right must blocked intervention set. intervention set anything inside smooth brackets (.e., variable set values). following valid effect statements: p{Y(X = 1) = 1} - p{Y(X = 0) = 1} p{X(Z = 1) = 1; X(Z = 0) = 0} p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1} constraints specified terms potential outcomes constrain writing potential outcomes, values parents, operators determine constraint (equalities inequalities). example, X(Z = 1) >= X(Z = 0)","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/analyze_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze the causal graph and effect to determine constraints and objective — analyze_graph","text":"","code":"### confounded exposure and outcome b <- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") #> Ready to compute bounds for the effect p{Y(X = 1) = 1} - p{Y(X = 0) = 1}  #>  Under the assumption encoded in the graph: + 3/3 edges from 8a38f91 (vertex names): #> [1] X ->Y Ur->X Ur->Y #> Number of possible values of each variable:  #>  X: 2, Y: 2  #> No constraints have been specified  #>  The bounds will be reported in terms of parameters of the form pab_, which represents the probability P(X = a, Y = b).  #> Additional information is available in the following list elements: [1] \"variables\"            \"parameters\"           \"constraints\"          #>  [4] \"objective\"            \"p.vals\"               \"q.vals\"               #>  [7] \"parsed.query\"         \"unparsed.query\"       \"user.constraints\"     #> [10] \"objective.nonreduced\" \"response.functions\"   \"graph\"                #> [13] \"R\"                    \"c0\"                   \"causal_model\""},{"path":"https://sachsmc.github.io/causaloptim/reference/btm_var.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursive function to get the last name in a list — btm_var","title":"Recursive function to get the last name in a list — btm_var","text":"Recursive function get last name list","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/btm_var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursive function to get the last name in a list — btm_var","text":"","code":"btm_var(x, name = NULL)"},{"path":"https://sachsmc.github.io/causaloptim/reference/btm_var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursive function to get the last name in a list — btm_var","text":"x list name name top element list","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/btm_var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursive function to get the last name in a list — btm_var","text":"name deepest nested list element","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/btm_var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursive function to get the last name in a list — btm_var","text":"","code":"btm_var(list(X = list(Y = list(K = 1)))) #> [1] \"K\""},{"path":"https://sachsmc.github.io/causaloptim/reference/causaloptim-package.html","id":null,"dir":"Reference","previous_headings":"","what":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects — causaloptim-package","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects — causaloptim-package","text":"Specify causal graphs using visual interactive interface analyze compute symbolic bounds causal effects terms observable parameters.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causaloptim-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects — causaloptim-package","text":"Run shiny app results <- specify_graph(). See detailed instructions vignette browseVignettes(\"causaloptim\").","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causaloptim-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects — causaloptim-package","text":"Sachs, M. C., Jonzon, G., Sjölander, ., & Gabriel, E. E. (2023). general method deriving tight symbolic bounds causal effects. Journal Computational Graphical Statistics, 32(2), 567-576. https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2071905 .","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/reference/causaloptim-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"An Interface to Specify Causal Graphs and Compute Bounds on Causal Effects — causaloptim-package","text":"Michael C Sachs, Arvid Sjölander, Gustav Jonzon, Alexander Balke, Colorado Reed, Erin Gabriel     Maintainer: Michael C Sachs <sachsmc gmail.com>","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causalproblemcheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check conditions on causal problem — causalproblemcheck","title":"Check conditions on causal problem — causalproblemcheck","text":"Check given causal problem (causal DAG together causal query) satisfies conditions guarantee optimization problem linear.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causalproblemcheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check conditions on causal problem — causalproblemcheck","text":"","code":"causalproblemcheck(digraph, query)"},{"path":"https://sachsmc.github.io/causaloptim/reference/causalproblemcheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check conditions on causal problem — causalproblemcheck","text":"digraph igraph object representing digraph. Expected vertex attributes: leftside, latent nvals. Optional vertex attributes: exposure outcome. Expected edge attributes: rlconnect edge.monotone. query string representing causal query / effect.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causalproblemcheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check conditions on causal problem — causalproblemcheck","text":"TRUE conditions met; FALSE otherwise.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/causalproblemcheck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check conditions on causal problem — causalproblemcheck","text":"","code":"b <- graph_from_literal(X - +Y, Ur - +X, Ur - +Y) V(b)$leftside <- c(0, 0, 0) V(b)$latent <- c(0, 0, 1) V(b)$nvals <- c(2, 2, 2) V(b)$exposure <- c(1, 0, 0) V(b)$outcome <- c(0, 1, 0) E(b)$rlconnect <- c(0, 0, 0) E(b)$edge.monotone <- c(0, 0, 0) effectt <- \"p{Y(X=1)=1}-p{Y(X=0)=1}\" causalproblemcheck(digraph = b, query = effectt) #> [1] TRUE"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_constraints_violated.html","id":null,"dir":"Reference","previous_headings":"","what":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","title":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","text":"Check whether observable constraints implied causal model violated given distribution observables","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_constraints_violated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","text":"","code":"check_constraints_violated(obj, probs, tol = 1e-12)"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_constraints_violated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","text":"obj object class \"causalmodel\" probs named vector observable probabilities, order obj$data$parameters tol Tolerance checking ()equalities","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_constraints_violated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","text":"Either TRUE (violated) FALSE (violated) messages indicating constraints violated .","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_constraints_violated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check whether any of the observable constraints implied by the causal model are violated for a given distribution of observables — check_constraints_violated","text":"","code":"graph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))  iv_model <- create_causalmodel(graph, prob.form = list(out = c(\"X\", \"Y\"), cond = \"Z\")) check_constraints_violated(iv_model, probs = sample_distribution(iv_model)) #> Constraints not violated #> [1] FALSE"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"Check linearity objective function implied causal model effect","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"","code":"check_linear_objective(causal_model, effectt)"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"causal_model object class \"causalmodel\" produce create_causalmodel effectt character string represents causal effect interest","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"logical value TRUE objective function linear","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"effectt parameter describes causal effect interest. effectt parameter must form p{V11(X=)=; V12(X=)=b;...} op1 p{V21(X=b)=; V22(X=c)=b;...} op2 ... Vij names variables graph, , b numeric values 0:(nvals - 1), op either - +. can specify single probability statement (.e., operator). Note probability statements begin little p, use curly braces, items inside probability statements separated ;. variables may potential outcomes denoted parentheses. Variables may also nested inside potential outcomes. following valid effect statements: p{Y(X = 1) = 1} - p{Y(X = 0) = 1} p{X(Z = 1) = 1; X(Z = 0) = 0} p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1} effect must fully specified, , parents variable intervened upon need specified. function infer missing values marginalize parents others.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_linear_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check linearity of objective function implied by a causal model and effect — check_linear_objective","text":"","code":"## regular IV case  ivgraph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y)) prob.form <- list(out = c(\"Y\", \"X\"), cond = \"Z\")  iv_model <- create_causalmodel(graph = ivgraph,             prob.form = prob.form) check_linear_objective(iv_model, effectt = \"p{Y(X = 1) = 1}\") #> [1] TRUE  #'  ## contaminated IV case  civgraph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Z-+ Y, Ur -+ X, Ur -+ Y))  cont_iv <- create_causalmodel(graph = civgraph, prob.form = prob.form)  check_linear_objective(cont_iv, effectt = \"p{Y(X = 1) = 1}\") #> [1] FALSE"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_parents.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for paths from from to to — check_parents","title":"Check for paths from from to to — check_parents","text":"Check paths ","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_parents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for paths from from to to — check_parents","text":"","code":"check_parents(parent_lookup, from, to, prev = NULL)"},{"path":"https://sachsmc.github.io/causaloptim/reference/check_parents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for paths from from to to — check_parents","text":"parent_lookup list vectors character character prev always null first called","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_parents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for paths from from to to — check_parents","text":"list paths null path found","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/check_parents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check for paths from from to to — check_parents","text":"","code":"parent_lookup <- list(M = \"Am\", Y = c(\"M\", \"Ay\"), A = NULL, Am = \"A\", Ay = \"A\") check_parents(parent_lookup, \"A\", \"Y\") #> $M #> $M$Am #> [1] \"A\"  \"Am\" \"M\"  \"Y\"  #>  #>  #> $Ay #> [1] \"A\"  \"Ay\" \"Y\"  #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/constraintscheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check constraints — constraintscheck","title":"Check constraints — constraintscheck","text":"Check user-provided constraint parsable, valid variables relations.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/constraintscheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check constraints — constraintscheck","text":"","code":"constraintscheck(constrainttext, graphres)"},{"path":"https://sachsmc.github.io/causaloptim/reference/constraintscheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check constraints — constraintscheck","text":"constrainttext string representing constraint. graphres igraph object representing DAG.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/constraintscheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check constraints — constraintscheck","text":"TRUE check pass; else FALSE.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/constraintscheck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check constraints — constraintscheck","text":"","code":"graphres <- graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y) V(graphres)$leftside <- c(1, 0, 0, 1, 0) V(graphres)$latent <- c(0, 0, 0, 1, 1) V(graphres)$nvals <- c(3, 2, 2, 2, 2) V(graphres)$exposure <- c(0, 1, 0, 0, 0) V(graphres)$outcome <- c(0, 0, 1, 0, 0) E(graphres)$rlconnect <- c(0, 0, 0, 0, 0) E(graphres)$edge.monotone <- c(0, 0, 0, 0, 0) constrainttext <- \"X(Z = 1) >= X(Z = 0)\" constraintscheck(constrainttext = constrainttext, graphres = graphres) # TRUE #> [1] TRUE"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"Given either graph set response functions (.e., either graph respvars may provided), specification conditional probabilities observed, produce causal model.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"","code":"create_causalmodel(   graph = NULL,   respvars = NULL,   prob.form,   p.vals,   constraints = NULL,   right.vars = NULL,   redundant = FALSE )"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"graph graph special edge vertex attributes, produced initialize_graph respvars List response functions produced create_response_function prob.form list two named elements \"\", \"cond\" element character vector variable names appear p.vals p.vals Data frame defining probabilities observable. variable names p.vals must appear prob.form. missing, assume combinations variables values observed. constraints vector character strings represent constraints counterfactual quantities right.vars vector character strings indicating variables right side graph. required graph NULL. See examples. redundant TRUE, removes redundant constraints deriving observable constraints.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"object class \"causalmodel\"","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"assumed probabilities form p(| cond) observed, combination values p.vals. cond may NULL case nothing conditioned . constraints specified terms potential outcomes constrain writing potential outcomes, values parents, operators determine constraint (equalities inequalities). example, X(Z = 1) >= X(Z = 0)","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_causalmodel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a structural causal model from a graph or a set of response functions — create_causalmodel","text":"","code":"## regular IV case  graph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y))  iv_model <- create_causalmodel(graph, prob.form = list(out = c(\"X\", \"Y\"), cond = \"Z\")) # with monotonicity iv_model_mono <- create_causalmodel(graph, prob.form = list(out = c(\"X\", \"Y\"), cond = \"Z\"),                  constraints = list(\"X(Z = 1) >= X(Z = 0)\"))                   #showing the use of right.vars b <- initialize_graph(graph_from_literal(Ul -+ X -+ Y -+ Y2, Ur -+ Y, Ur -+ Y2)) V(b)$latent <- c(1, 0, 1, 0, 1) respvars <- create_response_function(b) create_causalmodel(graph = b, constraints = \"Y2(Y = 1) >= Y2(Y = 0)\",                    p.vals = expand.grid(X = 0:1, Y2 = 0:1),                     prob.form = list(out = \"Y2\", cond = \"X\")) #> This is a causal model represented by the set of response functions in the x$data$response_functions element, where it is assumed that we observe parameters (observables) of the form pa_b, which represents the probability P(Y2 = a | X = b). To sample a distribution from this model, use sample_distribution(x). #> The observables relate to 12 unobservable variables which represent probabilities of particular response functions. The constraints are in the following equations and are available in numeric matrix form in the x$counterfactual_constraints$numeric$R element. #> q0_0 + q0_2 + q0_3 + q1_0 + q1_2 + q1_3 + q2_0 + q2_2 + q2_3 + q3_0 + q3_2 + q3_3  = 1 #> p0_0 = q0_0 + q0_2 + q1_0 + q2_0 + q2_2 + q3_0 #> p0_1 = q0_0 + q0_2 + q1_0 + q1_2 + q2_0 + q3_0 #> p1_0 = q0_3 + q1_2 + q1_3 + q2_3 + q3_2 + q3_3 #> p1_1 = q0_3 + q1_3 + q2_2 + q2_3 + q3_2 + q3_3 #> The causal model implies the following observable constraints in addition to the standard probabilistic constraints, which are available in numeric form in the x$observable_constraints$numeric element. To test whether these constraints are violated, use check_constraints_violated(x) #> No observable constraints other than the probabilistic constraints. To compute bounds, specify an effect of interest, and see the compute_bounds function.  ## need to specify right.vars because it cannot be inferred from the response functions alone create_causalmodel(graph = NULL, respvars = respvars,                     constraints = \"Y2(Y = 1) >= Y2(Y = 0)\",                    p.vals = expand.grid(X = 0:1, Y2 = 0:1),                     prob.form = list(out = \"Y2\", cond = \"X\"),                     right.vars = c(\"Y\", \"Y2\")) #> This is a causal model represented by the set of response functions in the x$data$response_functions element, where it is assumed that we observe parameters (observables) of the form pa_b, which represents the probability P(Y2 = a | X = b). To sample a distribution from this model, use sample_distribution(x). #> The observables relate to 12 unobservable variables which represent probabilities of particular response functions. The constraints are in the following equations and are available in numeric matrix form in the x$counterfactual_constraints$numeric$R element. #> q0_0 + q0_2 + q0_3 + q1_0 + q1_2 + q1_3 + q2_0 + q2_2 + q2_3 + q3_0 + q3_2 + q3_3  = 1 #> p0_0 = q0_0 + q0_2 + q1_0 + q2_0 + q2_2 + q3_0 #> p0_1 = q0_0 + q0_2 + q1_0 + q1_2 + q2_0 + q3_0 #> p1_0 = q0_3 + q1_2 + q1_3 + q2_3 + q3_2 + q3_3 #> p1_1 = q0_3 + q1_3 + q2_2 + q2_3 + q3_2 + q3_3 #> The causal model implies the following observable constraints in addition to the standard probabilistic constraints, which are available in numeric form in the x$observable_constraints$numeric element. To test whether these constraints are violated, use check_constraints_violated(x) #> No observable constraints other than the probabilistic constraints. To compute bounds, specify an effect of interest, and see the compute_bounds function."},{"path":"https://sachsmc.github.io/causaloptim/reference/create_effect_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate target effect to vector of response variables — create_effect_vector","title":"Translate target effect to vector of response variables — create_effect_vector","text":"Translate target effect vector response variables","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_effect_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate target effect to vector of response variables — create_effect_vector","text":"","code":"create_effect_vector(causal_model, effect)"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_effect_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate target effect to vector of response variables — create_effect_vector","text":"causal_model object class \"causalmodel\" produced create_causalmodel effect Effect list, returned parse_effect","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_effect_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate target effect to vector of response variables — create_effect_vector","text":"list target effect terms qs","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_effect_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate target effect to vector of response variables — create_effect_vector","text":"","code":"graph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y)) constraints <- \"X(Z = 1) >= X(Z = 0)\" effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\" p.vals <- expand.grid(Z = 0:1, X = 0:1, Y = 0:1) prob.form <- list(out = c(\"X\", \"Y\"), cond = \"Z\") effect <- parse_effect(effectt) ivmod <- create_causalmodel(graph, respvars = NULL, p.vals = p.vals, prob.form = prob.form,           constraints = constraints) var.eff <- create_effect_vector(ivmod, effect)"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":null,"dir":"Reference","previous_headings":"","what":"Create linear causal problem from causal model and effect — create_linearcausalproblem","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"flexible alternative analyze_graph takes inputs causal model effect.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"","code":"create_linearcausalproblem(causal_model, effectt)"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"causal_model object class \"causalmodel\" produce create_causalmodel effectt character string represents causal effect interest","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"object class \"linearcausalproblem\", list   following components. list can passed optimize_effect_2   interfaces symbolic optimization program. Print plot methods also   available. variables Character vector variable names   potential outcomes, start 'q' match Balke's notation parameters Character vector parameter names observed   probabilities, start 'p' match Balke's notation constraints Character vector parsed constraints objective Character string defining objective optimized   terms variables p.vals Matrix possible values   observed data vector, corresponding list parameters. q.vals Matrix possible values response function form   potential outcomes, corresponding list variables. parsed.query nested list containing information parsed   causal query. objective.nonreduced objective terms   original variables, algebraic variable reduction. nonreduced   variables can obtained concatenating columns q.vals. response.functions List response functions. graph graph passed function. R matrix coefficients   relating p.vals q.vals p = R * q c0 vector coefficients relating q.vals   objective function theta = c0 * q iqR matrix coefficients represent inequality   constraints","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"effectt parameter describes causal effect interest. effectt parameter must form p{V11(X=)=; V12(X=)=b;...} op1 p{V21(X=b)=; V22(X=c)=b;...} op2 ... Vij names variables graph, , b numeric values 0:(nvals - 1), op either - +. can specify single probability statement (.e., operator). Note probability statements begin little p, use curly braces, items inside probability statements separated ;. variables may potential outcomes denoted parentheses. Variables may also nested inside potential outcomes. Pure observations p{Y = 1} allowed left side contains variables. 2 important rules follow: 1) variables right side can probability events, left side empty: 2) none variables left side intervened upon can children left side, paths left right must blocked intervention set. intervention set anything inside smooth brackets (.e., variable set values). following valid effect statements: p{Y(X = 1) = 1} - p{Y(X = 0) = 1} p{X(Z = 1) = 1; X(Z = 0) = 0} p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_linearcausalproblem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create linear causal problem from causal model and effect — create_linearcausalproblem","text":"","code":"### confounded exposure and outcome b <- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) confmod <- create_causalmodel(graph = b, prob.form =  list(out = c(\"X\", \"Y\"), cond = NULL)) create_linearcausalproblem(confmod, effectt = \"p{Y(X = 1) = 1}\") #> Ready to compute bounds for the effect p{Y(X = 1) = 1}  #>  Under the assumption encoded in the graph: + 3/3 edges from 8f4b21e (vertex names): #> [1] X ->Y Ur->X Ur->Y #> Number of possible values of each variable:  #>  X: 2, Y: 2  #> No constraints have been specified  #>  The bounds will be reported in terms of parameters of the form pab_, which represents the probability P(X = a, Y = b).  #> Additional information is available in the following list elements: [1] \"variables\"            \"parameters\"           \"constraints\"          #>  [4] \"objective\"            \"p.vals\"               \"q.vals\"               #>  [7] \"parsed.query\"         \"unparsed.query\"       \"user.constraints\"     #> [10] \"objective.nonreduced\" \"response.functions\"   \"graph\"                #> [13] \"R\"                    \"c0\"                   \"causal_model\""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_q_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate response functions into matrix of counterfactuals — create_q_matrix","title":"Translate response functions into matrix of counterfactuals — create_q_matrix","text":"Translate response functions matrix counterfactuals","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_q_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate response functions into matrix of counterfactuals — create_q_matrix","text":"","code":"create_q_matrix(respvars, right.vars, cond.vars, constraints)"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_q_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate response functions into matrix of counterfactuals — create_q_matrix","text":"respvars list functions returned create_response_function right.vars Vertices graph right side cond.vars Vertices graph left side constraints vector character strings represent constraints","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_q_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate response functions into matrix of counterfactuals — create_q_matrix","text":"list 3 data frames counterfactuals associated labels","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_q_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate response functions into matrix of counterfactuals — create_q_matrix","text":"","code":"graphres <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y)) constraints <- \"X(Z = 1) >= X(Z = 0)\" cond.vars <- V(graphres)[V(graphres)$leftside == 1 & names(V(graphres)) != \"Ul\"] right.vars <- V(graphres)[V(graphres)$leftside == 0 & names(V(graphres)) != \"Ur\"]  respvars <- create_response_function(graphres) create_q_matrix(respvars, right.vars, cond.vars, constraints) #> $q.vals #>    X Y #> 1  0 0 #> 2  2 0 #> 3  3 0 #> 4  0 1 #> 5  2 1 #> 6  3 1 #> 7  0 2 #> 8  2 2 #> 9  3 2 #> 10 0 3 #> 11 2 3 #> 12 3 3 #>  #> $q.vals.all #>    X Y Z #> 1  0 0 0 #> 2  2 0 0 #> 3  3 0 0 #> 4  0 1 0 #> 5  2 1 0 #> 6  3 1 0 #> 7  0 2 0 #> 8  2 2 0 #> 9  3 2 0 #> 10 0 3 0 #> 11 2 3 0 #> 12 3 3 0 #> 13 0 0 1 #> 14 2 0 1 #> 15 3 0 1 #> 16 0 1 1 #> 17 2 1 1 #> 18 3 1 1 #> 19 0 2 1 #> 20 2 2 1 #> 21 3 2 1 #> 22 0 3 1 #> 23 2 3 1 #> 24 3 3 1 #>  #> $q.vals.all.lookup #> [1] Y   Z   X.x X.y #> <0 rows> (or 0-length row.names) #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_response_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate regular DAG to response functions — create_response_function","title":"Translate regular DAG to response functions — create_response_function","text":"Translate regular DAG response functions","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_response_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate regular DAG to response functions — create_response_function","text":"","code":"create_response_function(graph)"},{"path":"https://sachsmc.github.io/causaloptim/reference/create_response_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate regular DAG to response functions — create_response_function","text":"graph aaa-igraph-package object represents directed acyclic graph contains certain edge attributes.  shiny app returns graph format initialize_graph  add regular igraph object sensible defaults.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_response_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate regular DAG to response functions — create_response_function","text":"list functions representing response functions","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/create_response_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate regular DAG to response functions — create_response_function","text":"","code":"### confounded exposure and outcome b <- initialize_graph(igraph::graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) create_response_function(b) #> $X #> $X$index #> [1] 0 1 #>  #> $X$values #> $X$values[[1]] #> function ()  #> 0 #> <environment: base> #>  #> $X$values[[2]] #> function ()  #> 1 #> <environment: base> #>  #>  #> $X$matrices #> $X$matrices[[1]] #>      X #> [1,] 0 #>  #> $X$matrices[[2]] #>      X #> [1,] 1 #>  #>  #>  #> $Y #> $Y$index #> [1] 0 1 2 3 #>  #> $Y$values #> $Y$values[[1]] #> function (X = NULL)  #> switch(paste0(X), `0` = 0, `1` = 0) #> <environment: base> #>  #> $Y$values[[2]] #> function (X = NULL)  #> switch(paste0(X), `0` = 1, `1` = 0) #> <environment: base> #>  #> $Y$values[[3]] #> function (X = NULL)  #> switch(paste0(X), `0` = 0, `1` = 1) #> <environment: base> #>  #> $Y$values[[4]] #> function (X = NULL)  #> switch(paste0(X), `0` = 1, `1` = 1) #> <environment: base> #>  #>  #> $Y$matrices #> $Y$matrices[[1]] #>   X Y #> 1 0 0 #> 2 1 0 #>  #> $Y$matrices[[2]] #>   X Y #> 1 0 1 #> 2 1 0 #>  #> $Y$matrices[[3]] #>   X Y #> 1 0 0 #> 2 1 1 #>  #> $Y$matrices[[4]] #>   X Y #> 1 0 1 #> 2 1 1 #>  #>  #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/find_all_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Find all paths in a causal model — find_all_paths","title":"Find all paths in a causal model — find_all_paths","text":"Given set response functions, find directed paths ","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/find_all_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find all paths in a causal model — find_all_paths","text":"","code":"find_all_paths(respvars, from, to)"},{"path":"https://sachsmc.github.io/causaloptim/reference/find_all_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find all paths in a causal model — find_all_paths","text":"respvars set response functions created create_response_function character string indicating start path character string indicating end path","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/find_all_paths.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find all paths in a causal model — find_all_paths","text":"list paths list NULL none","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/find_all_paths.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find all paths in a causal model — find_all_paths","text":"","code":"b <- initialize_graph(igraph::graph_from_literal(X -+ Z, Z -+ Y, X -+ Y, Ur -+ Z, Ur -+ Y))  medmod <- create_response_function(b)  find_all_paths(medmod, \"X\", \"Y\") #> [1] \"X -> Y\"      \"X -> Z -> Y\"  igraph::all_simple_paths(b, \"X\", \"Y\", mode = \"out\") #> [[1]] #> + 3/4 vertices, named, from 908e6fd: #> [1] X Z Y #>  #> [[2]] #> + 2/4 vertices, named, from 908e6fd: #> [1] X Y #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/get_default_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Define default effect for a given graph — get_default_effect","title":"Define default effect for a given graph — get_default_effect","text":"Define default effect given graph","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/get_default_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define default effect for a given graph — get_default_effect","text":"","code":"get_default_effect(graphres)"},{"path":"https://sachsmc.github.io/causaloptim/reference/get_default_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define default effect for a given graph — get_default_effect","text":"graphres graph object, vertex attributes \"outcome\" \"exposure\"","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/get_default_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define default effect for a given graph — get_default_effect","text":"string can passed parse_effect","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/get_default_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define default effect for a given graph — get_default_effect","text":"","code":"graphres <- graph_from_literal(Z -+ X, X -+ Y, Ul -+ Z, Ur -+ X, Ur -+ Y) V(graphres)$leftside <- c(1, 0, 0, 1, 0) V(graphres)$latent <- c(0, 0, 0, 1, 1) V(graphres)$nvals <- c(3, 2, 2, 2, 2) V(graphres)$exposure <- c(0, 1, 0, 0, 0) V(graphres)$outcome <- c(0, 0, 1, 0, 0) E(graphres)$rlconnect <- c(0, 0, 0, 0, 0) E(graphres)$edge.monotone <- c(0, 0, 0, 0, 0) get_default_effect(graphres = graphres) == \"p{Y(X = 1)=1} - p{Y(X = 0)=1}\" # TRUE #> [1] TRUE"},{"path":"https://sachsmc.github.io/causaloptim/reference/graphrescheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check conditions on digraph — graphrescheck","title":"Check conditions on digraph — graphrescheck","text":"Check given digraph satisfies conditions 'left right edges', 'cycles', 'valid number categories' 'valid variable names'. Optionally returns digraph checks passed.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/graphrescheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check conditions on digraph — graphrescheck","text":"","code":"graphrescheck(graphres, ret = FALSE)"},{"path":"https://sachsmc.github.io/causaloptim/reference/graphrescheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check conditions on digraph — graphrescheck","text":"graphres igraph object representing digraph. ret logical value. Default FALSE. Set TRUE also return graphres checks passed.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/graphrescheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check conditions on digraph — graphrescheck","text":"ret=FALSE (default): TRUE checks pass; else FALSE. ret=TRUE: graphres checks pass; else FALSE.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/graphrescheck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check conditions on digraph — graphrescheck","text":"","code":"graphres <- graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ M, Ur -+ Y) V(graphres)$leftside <- c(1, 0, 0, 1, 0) V(graphres)$latent <- c(0, 0, 0, 1, 1) V(graphres)$nvals <- c(2, 2, 2, 2, 2) V(graphres)$exposure <- c(0, 0, 0, 0, 0) V(graphres)$outcome <- c(0, 0, 0, 0, 0) E(graphres)$rlconnect <- c(0, 0, 0, 0, 0, 0) E(graphres)$edge.monotone <- c(0, 0, 0, 0, 0, 0) graphrescheck(graphres = graphres) # TRUE #> [1] TRUE"},{"path":"https://sachsmc.github.io/causaloptim/reference/initialize_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Initialize an igraph object for use with causaloptim — initialize_graph","title":"Initialize an igraph object for use with causaloptim — initialize_graph","text":"Checks required attributes adds defaults missing","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/initialize_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initialize an igraph object for use with causaloptim — initialize_graph","text":"","code":"initialize_graph(graph)"},{"path":"https://sachsmc.github.io/causaloptim/reference/initialize_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initialize an igraph object for use with causaloptim — initialize_graph","text":"graph object class igraph","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/initialize_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initialize an igraph object for use with causaloptim — initialize_graph","text":"igraph vertex attributes leftside, latent, nvals, edge attributes rlconnect edge.monotone","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/initialize_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Initialize an igraph object for use with causaloptim — initialize_graph","text":"","code":"b <- igraph::graph_from_literal(X -+ Y) b2 <- initialize_graph(b) V(b2)$nvals #> [1] 2 2"},{"path":"https://sachsmc.github.io/causaloptim/reference/interpret_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert bounds string to a function — interpret_bounds","title":"Convert bounds string to a function — interpret_bounds","text":"Convert bounds string function","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/interpret_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert bounds string to a function — interpret_bounds","text":"","code":"interpret_bounds(bounds, parameters)"},{"path":"https://sachsmc.github.io/causaloptim/reference/interpret_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert bounds string to a function — interpret_bounds","text":"bounds bounds element returned optimize_effect parameters Character vector defining parameters, returned analyze_graph","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/interpret_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert bounds string to a function — interpret_bounds","text":"function takes arguments parameters, .e., observed probabilities returns vector length 2: lower bound upper bound.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/interpret_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert bounds string to a function — interpret_bounds","text":"","code":"b <- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(0,0,0) V(b)$latent <- c(0,0,1) V(b)$nvals <- c(2,2,2) E(b)$rlconnect <- E(b)$edge.monotone <- c(0, 0, 0) obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") bounds <- optimize_effect_2(obj) bounds_func <- interpret_bounds(bounds$bounds, obj$parameters) bounds_func(.1, .1, .4, .3) #>   lower upper #> 1  -0.5   0.5 # vectorized do.call(bounds_func, lapply(1:4, function(i) runif(5))) #>       lower       upper #> 1 -1.429489 -0.42948891 #> 2 -0.914107  0.08589296 #> 3 -1.157299 -0.15729874 #> 4 -1.186872 -0.18687167 #> 5 -1.082417 -0.08241683"},{"path":"https://sachsmc.github.io/causaloptim/reference/latex_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Latex bounds equations — latex_bounds","title":"Latex bounds equations — latex_bounds","text":"Latex bounds equations","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/latex_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Latex bounds equations — latex_bounds","text":"","code":"latex_bounds(bounds, parameters, prob.sym = \"P\", brackets = c(\"(\", \")\"))"},{"path":"https://sachsmc.github.io/causaloptim/reference/latex_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Latex bounds equations — latex_bounds","text":"bounds Vector bounds returned optimize_effect_2 parameters parameters object returned analyze_graph prob.sym Symbol use probability statements latex, usually \"P\" \"pr\" brackets Length 2 vector opening closing bracket, usually c(\"(\", \")\"), c(\" \\{\", \"\\}\")","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/latex_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Latex bounds equations — latex_bounds","text":"character string latex code bounds","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/latex_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Latex bounds equations — latex_bounds","text":"","code":"b <- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(0,0,0) V(b)$latent <- c(0,0,1) V(b)$nvals <- c(2,2,2) E(b)$rlconnect <- E(b)$edge.monotone <- c(0, 0, 0) obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") bounds <- optimize_effect_2(obj) latex_bounds(bounds$bounds, obj$parameters) #> [1] \"\\\\[ \\n \\\\mbox{Lower bound} =   -P(X = 1, Y = 0) - P(X = 0, Y = 1) \\n \\\\] \\n \\\\[ \\n \\\\mbox{Upper bound} =   1 - P(X = 1, Y = 0) - P(X = 0, Y = 1) \\n \\\\] \\n\" latex_bounds(bounds$bounds, obj$parameters, \"Pr\") #> [1] \"\\\\[ \\n \\\\mbox{Lower bound} =   -Pr(X = 1, Y = 0) - Pr(X = 0, Y = 1) \\n \\\\] \\n \\\\[ \\n \\\\mbox{Upper bound} =   1 - Pr(X = 1, Y = 0) - Pr(X = 0, Y = 1) \\n \\\\] \\n\""},{"path":"https://sachsmc.github.io/causaloptim/reference/list_to_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursive function to translate an effect list to a path sequence — list_to_path","title":"Recursive function to translate an effect list to a path sequence — list_to_path","text":"Recursive function translate effect list path sequence","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/list_to_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursive function to translate an effect list to a path sequence — list_to_path","text":"","code":"list_to_path(x, name = NULL)"},{"path":"https://sachsmc.github.io/causaloptim/reference/list_to_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursive function to translate an effect list to a path sequence — list_to_path","text":"x list vars returned parse_effect name name outcome variable","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/list_to_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursive function to translate an effect list to a path sequence — list_to_path","text":"list characters describing path sequence","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/list_to_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recursive function to translate an effect list to a path sequence — list_to_path","text":"","code":"nofill <- \"p{Y(X = 1, M1 = 1, M2(X = 1, M1 = 1)) = 1}\" eff2 <- parse_effect(nofill)$vars[[1]][[1]] list_to_path(eff2, \"Y\") #> [[1]] #> X -> Y  #>      1  #>  #> [[2]] #> M1 -> Y  #>       1  #>  #> [[3]] #>  X -> M2 -> Y M1 -> M2 -> Y  #>             1             1  #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/optimize_effect_2.html","id":null,"dir":"Reference","previous_headings":"","what":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","title":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","text":"Given object linear programming problem set , compute bounds using rcdd. Bounds returned text can converted R functions using interpret_bounds, latex code using latex_bounds.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/optimize_effect_2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","text":"","code":"optimize_effect_2(obj, redundant = FALSE)"},{"path":"https://sachsmc.github.io/causaloptim/reference/optimize_effect_2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","text":"obj Object returned analyze_graph create_linearcausalproblem redundant TRUE, removed redundant constraints preprocessing step. Can speed things .","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/optimize_effect_2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","text":"object class \"balkebound\" list contains bounds logs character strings, function compute bounds","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/optimize_effect_2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run the optimizer to obtain symbolic bounds — optimize_effect_2","text":"","code":"b <- initialize_graph(graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") optimize_effect_2(obj) #> lower bound =   #> MAX { #>   -p10_ - p01_ #> } #> ---------------------------------------- #> upper bound =   #> MIN { #>   1 - p10_ - p01_ #> } #>  #> A function to compute the bounds for a given set of probabilities is available in the x$bounds_function element."},{"path":"https://sachsmc.github.io/causaloptim/reference/opt_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a bound on the average causal effect — opt_effect","title":"Compute a bound on the average causal effect — opt_effect","text":"helper function heavy lifting optimize_effect_2. given casual query, computes either lower upper bound corresponding causal effect.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/opt_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a bound on the average causal effect — opt_effect","text":"","code":"opt_effect(opt, obj, redundant)"},{"path":"https://sachsmc.github.io/causaloptim/reference/opt_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a bound on the average causal effect — opt_effect","text":"opt string. Either \"min\" \"max\" lower upper bound, respectively. obj object returned function analyze_graph. Contains casual query estimated. redundant TRUE, removed redundant constraints preprocessing step. Can speed things .","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/opt_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a bound on the average causal effect — opt_effect","text":"object class optbound; list following named components: expr main output; expression bound print-friendly string, type either \"lower\" \"upper\" according type bound, dual_vertices numeric matrix whose rows vertices convex polytope dual LP, dual_vrep V-representation dual convex polytope, including extra data.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse text that defines a the constraints — parse_constraints","title":"Parse text that defines a the constraints — parse_constraints","text":"Parse text defines constraints","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse text that defines a the constraints — parse_constraints","text":"","code":"parse_constraints(constraints, obsnames)"},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse text that defines a the constraints — parse_constraints","text":"constraints list character strings obsnames Vector names observed variables graph","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse text that defines a the constraints — parse_constraints","text":"data frame columns indicating variables constrained, values parents constraints, operator defining constraint (equality inequalities).","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse text that defines a the constraints — parse_constraints","text":"","code":"constrainttext <- \"X(Z = 1) >= X(Z = 0)\" obsnames <- c(\"Z\", \"X\", \"Y\") parse_constraints(constraints = constrainttext, obsnames = obsnames) #>   leftout rightout operator leftcond rightcond #> 1       X        X       >=      Z=1       Z=0"},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse text that defines a causal effect — parse_effect","title":"Parse text that defines a causal effect — parse_effect","text":"Parse text defines causal effect","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse text that defines a causal effect — parse_effect","text":"","code":"parse_effect(text)"},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse text that defines a causal effect — parse_effect","text":"text Character string","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse text that defines a causal effect — parse_effect","text":"nested list contains following components: vars element causal query,        indicates potential outcomes names list elements,        variables depend , values variables fixed . oper vector operators (addition subtraction) combine terms causal query. values values potential outcomes set query. pcheck List logicals element query TRUE element        potential outcome FALSE observational quantity.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/parse_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse text that defines a causal effect — parse_effect","text":"","code":"effectt <- \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\" parse_effect(text = effectt) #> $vars #> $vars[[1]] #> $vars[[1]]$Y #> $vars[[1]]$Y$X #> [1] 1 #>  #>  #>  #> $vars[[2]] #> $vars[[2]]$Y #> $vars[[2]]$Y$X #> [1] 0 #>  #>  #>  #>  #> $oper #> $oper[[1]] #> [1] \"-\" #>  #>  #> $values #> $values[[1]] #> $values[[1]]$Y #> [1] 1 #>  #>  #> $values[[2]] #> $values[[2]]$Y #> [1] 1 #>  #>  #>  #> $pcheck #> $pcheck[[1]] #> [1] TRUE #>  #> $pcheck[[2]] #> [1] TRUE #>  #>"},{"path":"https://sachsmc.github.io/causaloptim/reference/plot.linearcausalproblem.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","title":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","text":"Plot graph causal problem legend describing attributes","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/plot.linearcausalproblem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","text":"","code":"# S3 method for class 'linearcausalproblem' plot(x, ...)"},{"path":"https://sachsmc.github.io/causaloptim/reference/plot.linearcausalproblem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","text":"x object class \"linearcausalproblem\" ... used","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/plot.linearcausalproblem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","text":"Nothing","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/reference/plot.linearcausalproblem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the graph from the causal problem with a legend describing attributes — plot.linearcausalproblem","text":"","code":"b <- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(0,0,0) V(b)$latent <- c(0,0,1) V(b)$nvals <- c(2,2,2) V(b)$exposure <- c(1,0,0) V(b)$outcome <- c(0,1,0) E(b)$rlconnect <- c(0,0,0) E(b)$edge.monotone <- c(0,0,0) q <- \"p{Y(X=1)=1}-p{Y(X=0)=1}\" obj <- analyze_graph(graph = b, constraints = NULL, effectt <- q) plot(obj)"},{"path":"https://sachsmc.github.io/causaloptim/reference/plot_graphres.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the analyzed graph object — plot_graphres","title":"Plot the analyzed graph object — plot_graphres","text":"Special plotting method igraphs type","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/plot_graphres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the analyzed graph object — plot_graphres","text":"","code":"plot_graphres(graphres)"},{"path":"https://sachsmc.github.io/causaloptim/reference/plot_graphres.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the analyzed graph object — plot_graphres","text":"graphres igraph object","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/plot_graphres.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the analyzed graph object — plot_graphres","text":"None","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/reference/plot_graphres.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the analyzed graph object — plot_graphres","text":"","code":"b <- graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y) V(b)$leftside <- c(0,0,0) V(b)$latent <- c(0,0,1) V(b)$nvals <- c(2,2,2) V(b)$exposure <- c(1,0,0) V(b)$outcome <- c(0,1,0) E(b)$rlconnect <- c(0,0,0) E(b)$edge.monotone <- c(0,0,0) plot(b)"},{"path":"https://sachsmc.github.io/causaloptim/reference/print.causalmodel.html","id":null,"dir":"Reference","previous_headings":"","what":"Print relevant information about the causal model — print.causalmodel","title":"Print relevant information about the causal model — print.causalmodel","text":"Print relevant information causal model","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/print.causalmodel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print relevant information about the causal model — print.causalmodel","text":"","code":"# S3 method for class 'causalmodel' print(x, omit_cf_constraints = FALSE, omit_obs_constraints = FALSE, ...)"},{"path":"https://sachsmc.github.io/causaloptim/reference/print.causalmodel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print relevant information about the causal model — print.causalmodel","text":"x object class \"causalmodel\" omit_cf_constraints print counterfactual constraints omit_obs_constraints print observable constraints ... used","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/print.causalmodel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print relevant information about the causal model — print.causalmodel","text":"x, invisibly","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/print.linearcausalproblem.html","id":null,"dir":"Reference","previous_headings":"","what":"Print the causal problem — print.linearcausalproblem","title":"Print the causal problem — print.linearcausalproblem","text":"Print causal problem","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/print.linearcausalproblem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print the causal problem — print.linearcausalproblem","text":"","code":"# S3 method for class 'linearcausalproblem' print(x, ...)"},{"path":"https://sachsmc.github.io/causaloptim/reference/print.linearcausalproblem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print the causal problem — print.linearcausalproblem","text":"x object class \"linearcausaloptim\" ... used","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/print.linearcausalproblem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print the causal problem — print.linearcausalproblem","text":"x, invisibly","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/querycheck.html","id":null,"dir":"Reference","previous_headings":"","what":"Check conditions on query — querycheck","title":"Check conditions on query — querycheck","text":"Given admissible causal DAG, check given causal query satisfies conditions guarantee corresponding causal problem linear program. Throws error messages detailing conditions violated.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/querycheck.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check conditions on query — querycheck","text":"","code":"querycheck(effecttext, graphres)"},{"path":"https://sachsmc.github.io/causaloptim/reference/querycheck.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check conditions on query — querycheck","text":"effecttext string representing causal query. graphres igraph object representing digraph.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/querycheck.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check conditions on query — querycheck","text":"TRUE effecttext parsable, contains variables V(graphres) satisfies conditions linearity; else FALSE.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/querycheck.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check conditions on query — querycheck","text":"","code":"graphres <- graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ M, Ur -+ Y) V(graphres)$leftside <- c(1, 0, 0, 1, 0) V(graphres)$latent <- c(0, 0, 0, 1, 1) V(graphres)$nvals <- c(2, 2, 2, 2, 2) V(graphres)$exposure <- c(0, 0, 0, 0, 0) V(graphres)$outcome <- c(0, 0, 0, 0, 0) E(graphres)$rlconnect <- c(0, 0, 0, 0, 0, 0) E(graphres)$edge.monotone <- c(0, 0, 0, 0, 0, 0) effecttext <- \"p{Y(M(X = 0), X = 1) = 1} - p{Y(M(X = 0), X = 0) = 1}\" querycheck(effecttext = effecttext, graphres = graphres) # TRUE #> [1] TRUE"},{"path":"https://sachsmc.github.io/causaloptim/reference/rdirichlet.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from a Dirichlet distribution — rdirichlet","title":"Sample from a Dirichlet distribution — rdirichlet","text":"Generate random vector k-dimensional symmetric Dirichlet distribution concentration parameter alpha","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/rdirichlet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from a Dirichlet distribution — rdirichlet","text":"","code":"rdirichlet(k, alpha = 1)"},{"path":"https://sachsmc.github.io/causaloptim/reference/rdirichlet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from a Dirichlet distribution — rdirichlet","text":"k Length vector alpha Concentration parameters","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/rdirichlet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from a Dirichlet distribution — rdirichlet","text":"numeric vector","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/rdirichlet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from a Dirichlet distribution — rdirichlet","text":"","code":"qvals <- rdirichlet(16, 1) sum(qvals) #> [1] 1"},{"path":"https://sachsmc.github.io/causaloptim/reference/sample_distribution.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","title":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","text":"Sample distribution observable probabilities satisfy causal model","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/sample_distribution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","text":"","code":"sample_distribution(   obj,   simplex_sampler = function(k) {      rdirichlet(k, alpha = 1)  } )"},{"path":"https://sachsmc.github.io/causaloptim/reference/sample_distribution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","text":"obj object class \"causalmodel\" simplex_sampler function generate random sample simplex k dimensions, k number variables (q parameters, obj$data$variables). default uniform (symmetric dirichlet parameter 1).","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/sample_distribution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","text":"vector observable probabilities satisfy causal model","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/sample_distribution.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample a distribution of observable probabilities that satisfy the causal model — sample_distribution","text":"","code":"graph <- initialize_graph(graph_from_literal(Z -+ X, X -+ Y, Ur -+ X, Ur -+ Y)) prob.form <- list(out = c(\"X\", \"Y\"), cond = \"Z\")  iv_model <- create_causalmodel(graph, prob.form = prob.form) sample_distribution(iv_model) #>     p00_0     p10_0     p01_0     p11_0     p00_1     p10_1     p01_1     p11_1  #> 0.2118650 0.1877245 0.2308965 0.3695140 0.2485062 0.1850746 0.2028510 0.3635681"},{"path":"https://sachsmc.github.io/causaloptim/reference/simulate_bounds.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate bounds — simulate_bounds","title":"Simulate bounds — simulate_bounds","text":"Run simple simulation based bounds. simulation, sample set counterfactual probabilities uniform distribution, translate multinomial distribution, compute objective bounds terms observable variables.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/simulate_bounds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate bounds — simulate_bounds","text":"","code":"simulate_bounds(obj, bounds, nsim = 1000)"},{"path":"https://sachsmc.github.io/causaloptim/reference/simulate_bounds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate bounds — simulate_bounds","text":"obj Object returned analyze_graph bounds Object returned optimize_effect_2 nsim Number simulation replicates","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/simulate_bounds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate bounds — simulate_bounds","text":"data frame columns: objective, bound.lower, bound.upper","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/simulate_bounds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate bounds — simulate_bounds","text":"","code":"b <- initialize_graph(graph_from_literal(X -+ Y, Ur -+ X, Ur -+ Y)) obj <- analyze_graph(b, constraints = NULL, effectt = \"p{Y(X = 1) = 1} - p{Y(X = 0) = 1}\") bounds <- optimize_effect_2(obj) simulate_bounds(obj, bounds, nsim = 5) #>     objective bound.lower bound.upper #> 1  0.29136748  -0.3729966   0.6270034 #> 2 -0.06331950  -0.4469019   0.5530981 #> 3 -0.26156878  -0.6549510   0.3450490 #> 4 -0.15481633  -0.7029335   0.2970665 #> 5 -0.03916506  -0.4966841   0.5033159"},{"path":"https://sachsmc.github.io/causaloptim/reference/specify_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Shiny interface to specify network structure and compute bounds — specify_graph","title":"Shiny interface to specify network structure and compute bounds — specify_graph","text":"launches Shiny interface system's default web browser. results computation displayed browser, can also returned R session assigning result function call object. See information returned.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/specify_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shiny interface to specify network structure and compute bounds — specify_graph","text":"","code":"specify_graph()"},{"path":"https://sachsmc.github.io/causaloptim/reference/specify_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shiny interface to specify network structure and compute bounds — specify_graph","text":"button \"Exit return graph object\" clicked,     graph returned aaa-igraph-package object. bounds computed button \"Exit return objects R\" clicked,     list returned following elements:  graphres graph drawn interpreted, aaa-igraph-package object. obj objective necessary supporting information. object        documented analyze_graph. can passed directly optimize_effect_2. bounds.obs Object class 'balkebound' returned optimize_effect_2. constraints Character vector specified constraints. NULL constraints. effect Text describing causal effect interest. boundsFunction Function takes parameters (observed probabilities) arguments, returns vector length 2 lower upper bounds.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/update_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Update the effect in a linearcausalproblem object — update_effect","title":"Update the effect in a linearcausalproblem object — update_effect","text":"want use graph response function, change effect interest, can save computation time.","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/update_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update the effect in a linearcausalproblem object — update_effect","text":"","code":"update_effect(obj, effectt)"},{"path":"https://sachsmc.github.io/causaloptim/reference/update_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update the effect in a linearcausalproblem object — update_effect","text":"obj object returned analyze_graph effectt character string represents causal effect interest","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/update_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update the effect in a linearcausalproblem object — update_effect","text":"object class linearcausalproblem, see analyze_graph details","code":""},{"path":"https://sachsmc.github.io/causaloptim/reference/update_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update the effect in a linearcausalproblem object — update_effect","text":"","code":"b <- igraph::graph_from_literal(X -+ Y, X -+ M, M -+ Y, Ul -+ X, Ur -+ Y, Ur -+ M) V(b)$leftside <- c(1, 0, 0, 1, 0) V(b)$latent <- c(0, 0, 0, 1, 1) V(b)$nvals <- c(2, 2, 2, 2, 2) E(b)$rlconnect <- c(0, 0, 0, 0, 0, 0) E(b)$edge.monotone <- c(0, 0, 0, 0, 0, 0) CDE0_query <- \"p{Y(M = 0, X = 1) = 1} - p{Y(M = 0, X = 0) = 1}\" CDE0_obj <- analyze_graph(b, constraints = NULL, effectt = CDE0_query) CDE0_bounds <- optimize_effect_2(CDE0_obj) CDE0_boundsfunction <- interpret_bounds(bounds = CDE0_bounds$bounds,  parameters = CDE0_obj$parameters) CDE1_query <- \"p{Y(M = 1, X = 1) = 1} - p{Y(M = 1, X = 0) = 1}\" CDE1_obj <- update_effect(CDE0_obj, effectt = CDE1_query) CDE1_bounds <- optimize_effect_2(CDE1_obj) CDE1_boundsfunction <- interpret_bounds(bounds = CDE1_bounds$bounds,  parameters = CDE1_obj$parameters)"},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-101","dir":"Changelog","previous_headings":"","what":"causaloptim 1.0.1","title":"causaloptim 1.0.1","text":"New features - Add option use rcdd::redundant speed calculation bounds. Note results equivalent terms may different order. - Add redundant option also create_causalmodel","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-100","dir":"Changelog","previous_headings":"","what":"causaloptim 1.0.0","title":"causaloptim 1.0.0","text":"CRAN release: 2024-10-17 Major release lots changes: Balke’s legacy C++ code longer supported. Vertex enumeration now always done rcdd New interface specify causal model without effect. Also derivation observable constraints checking linearity Various bug fixes improvements","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-0100","dir":"Changelog","previous_headings":"","what":"causaloptim 0.10.0","title":"causaloptim 0.10.0","text":"experimental functionality automated linearity checking","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-098","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.8","title":"causaloptim 0.9.8","text":"CRAN release: 2023-10-31 complete refactor shiny app (@gjo11) add tests shiny ui server components (@gjo11) update documentation clean exports (@gjo11)","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-097","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.7","title":"causaloptim 0.9.7","text":"CRAN release: 2023-03-24 fixes snprintf LEN_LABEL Fixed warnings Balke’s old cpp code update bibentry","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-093","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.3","title":"causaloptim 0.9.3","text":"CRAN release: 2023-01-22 Minor bug fixes Balke’s old code (sprintf -> snprintf) removed methods vignette linked published article instead (open access, please email can’t access ) bugfix ensure parameters get removed constraints make impossible","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-092","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.2","title":"causaloptim 0.9.2","text":"CRAN release: 2022-03-25","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bug-fixes-0-9-2","dir":"Changelog","previous_headings":"","what":"bug fixes","title":"causaloptim 0.9.2","text":"Fixed parsing issue latex_bounds","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-092-1","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.2","title":"causaloptim 0.9.2","text":"CRAN release: 2022-03-25","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bug-fixes-0-9-2-1","dir":"Changelog","previous_headings":"","what":"bug fixes","title":"causaloptim 0.9.2","text":"Fixed c++ compiler warning length buffer Tableau.cpp","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-091","dir":"Changelog","previous_headings":"","what":"causaloptim 0.9.1","title":"causaloptim 0.9.1","text":"CRAN release: 2021-12-10","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"more-big-new-features-0-9-1","dir":"Changelog","previous_headings":"","what":"More big new features!","title":"causaloptim 0.9.1","text":"categorical variables now handled Update shiny UI enable specification categorical variables Update draft methods paper vignette","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bug-fixes-0-9-1","dir":"Changelog","previous_headings":"","what":"bug fixes","title":"causaloptim 0.9.1","text":"Fixed propagation intervention sets downstream crossed effects","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-082","dir":"Changelog","previous_headings":"","what":"causaloptim 0.8.2","title":"causaloptim 0.8.2","text":"CRAN release: 2021-06-09","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"big-new-features-0-8-2","dir":"Changelog","previous_headings":"","what":"Big new features!","title":"causaloptim 0.8.2","text":"Major update vertex enumeration algorithm (thanks @gjo11). new function called optimize_effect_2 uses rcdd package enumerate vertices. significantly faster Balke’s C++ code. function used default shiny app. minor differences bounds displayed, note display vertices within MIN MAX may differ optimize_effect. bounds equivalent (just different order) test cases looked . New vignette explaining optimization implemented (also thanks @gjo11)","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"small-features-0-8-2","dir":"Changelog","previous_headings":"","what":"Small features","title":"causaloptim 0.8.2","text":"interpret_bounds returns function now give warning bounds invalid. Pull steps analyze_graph separate modules.","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-8-2","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.8.2","text":"Make sure qs unique large problems","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-071","dir":"Changelog","previous_headings":"","what":"causaloptim 0.7.1","title":"causaloptim 0.7.1","text":"CRAN release: 2020-05-07","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-7-1","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.7.1","text":"Propagation intervention set paths defined Checking violations condition 6 effect","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"new-features-0-7-1","dir":"Changelog","previous_headings":"","what":"New features","title":"causaloptim 0.7.1","text":"Additional information returned analyze_graph Better printing analyze_graph objects","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-065","dir":"Changelog","previous_headings":"","what":"causaloptim 0.6.5","title":"causaloptim 0.6.5","text":"CRAN release: 2020-03-25","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-6-5","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.6.5","text":"Fixed mismatched new/delete/delete[] C++ code","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-064","dir":"Changelog","previous_headings":"","what":"causaloptim 0.6.4","title":"causaloptim 0.6.4","text":"CRAN release: 2020-03-20","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-6-4","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.6.4","text":"Parse effect fixed joint outcome probabilities. Added examples Update description","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-6-3","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.6.3","text":"Refactor algorithm 1 works correctly unobserved variables Fix probability printing shiny app unobserved variables","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-6-2","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.6.2","text":"Fixed repeated qs bug affects graphs multiple variables left side Added citation file","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"minor-updates-0-6-1","dir":"Changelog","previous_headings":"","what":"Minor updates","title":"causaloptim 0.6.1","text":"Allow user interrupt long-running c++ loops Increase maximum number vertices Added progress indicator shiny app Update dependencies","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"New features","title":"causaloptim 0.6.0","text":"Allow observed variables causal effect. E.g., treatment effect among treated p{Y(X = 1) = 1; X = 1} - p{Y(X = 0) = 1; X = 1}","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-5-3","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.5.3","text":"Fixed warnings CRAN check Added travis ci Lowercase min max latex Additional documentation shiny app","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bugfixes-0-5-2","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"causaloptim 0.5.2","text":"Better reset functionality shiny app","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"new-features-0-5-1","dir":"Changelog","previous_headings":"","what":"New features","title":"causaloptim 0.5.1","text":"button print latex code shiny app Checking intervention set children rightside error checks bugfixes","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"causaloptim 0.5.0","text":"latex printing bounds","code":""},{"path":[]},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"bug-fixes-0-4-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"causaloptim 0.4.1","text":"Bugfixes parsing bounds CRAN checks","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"new-features-0-4-1","dir":"Changelog","previous_headings":"","what":"New features","title":"causaloptim 0.4.1","text":"Error checking parse effect parse constraints shiny app","code":""},{"path":"https://sachsmc.github.io/causaloptim/news/index.html","id":"causaloptim-030","dir":"Changelog","previous_headings":"","what":"causaloptim 0.3.0","title":"causaloptim 0.3.0","text":"Rebuilt interface, text based now.","code":""}]
